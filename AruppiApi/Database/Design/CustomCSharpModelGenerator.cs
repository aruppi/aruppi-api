using Microsoft.EntityFrameworkCore.Design;
using Microsoft.EntityFrameworkCore.Design.Internal;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Scaffolding;
using Microsoft.EntityFrameworkCore.Scaffolding.Internal;
using System.Text.RegularExpressions;

namespace AruppiApi.Database.Design;

// Magically found by EF via reflection
public class CustomDesignTimeServices : IDesignTimeServices
{
    public void ConfigureDesignTimeServices(IServiceCollection serviceCollection)
    {
        serviceCollection.AddTransient<IModelCodeGenerator, CustomCSharpModelGenerator>();
    }
}

// With this class we are modifying the code generated by ef core database reverse engineering
// This way we can make the generated model fit our needs better
public class CustomCSharpModelGenerator : CSharpModelGenerator
{
    private static readonly string BaseClassName = "BaseEntity";
    private static readonly string BaseClassInheritance = $" : {BaseClassName}";
    private static readonly string BaseClass = $"\npublic abstract partial class {BaseClassName} {{ public abstract Guid Id {{ get; set; }} }}";
    private static readonly Regex FindNamespacePattern = new Regex(@"(namespace .*;)", RegexOptions.Compiled);
    private static readonly Regex RegexModifyInheritancePattern = new Regex(@"(public partial class \w+)", RegexOptions.Compiled);
    private static readonly List<(string old, string @new)> StaticReplacements = new List<(string, string)>()
    {
        ("ICollection<", "IList<"),
        ("public Guid Id { get; set; }", "public override Guid Id { get; set; }"),
        ("public DateOnly? Premiered { get; set; }", "public string? Premiered { get; set; }"),
        ("public DateOnly? Ended { get; set; }", "public string? Ended { get; set; }"),
    };

    public CustomCSharpModelGenerator(ModelCodeGeneratorDependencies dependencies, IOperationReporter reporter, IServiceProvider serviceProvider) : base(dependencies, reporter, serviceProvider)
    {

    }

    public override ScaffoldedModel GenerateModel(IModel model, ModelCodeGenerationOptions options)
    {
        ScaffoldedModel? defaultModel = base.GenerateModel(model, options);
        var modelFiles = defaultModel.AdditionalFiles;

        string? detectedNamespace = null;

        for (int fileIndex = 0; fileIndex < modelFiles.Count; fileIndex++)
        {
            var modelFile = modelFiles[fileIndex];

            if (!modelFile.Code.Contains("public Guid Id { get; set; }"))
            {
                continue;
            }

            if (detectedNamespace is null)
            {
                var match = FindNamespacePattern.Match(modelFile.Code);

                detectedNamespace = match.Value;
            }

            // Regex Is Powerful but those are faster
            for (int replacementIndex = 0; replacementIndex < StaticReplacements.Count; replacementIndex++)
            {
                var pattern = StaticReplacements[replacementIndex];

                modelFile.Code = modelFile.Code.Replace(pattern.old, pattern.@new);
            }

            modelFile.Code = RegexModifyInheritancePattern.Replace(modelFile.Code, evaluator =>
            {
                if (evaluator.Value.StartsWith("public partial class"))
                {
                    var value = evaluator.Value + BaseClassInheritance;
                    return value;
                }

                throw new Exception("This Shouldn't Have Happened, You Should Review The Custom Scaffolding Code Generator");
            });
        }

        if (detectedNamespace is not null && defaultModel.ContextFile.Path is string contextPath)
        {
            contextPath = Path.GetDirectoryName(contextPath)!;

            contextPath = Path.Combine(contextPath, $"{BaseClassName}.cs");

            modelFiles.Add(new ScaffoldedFile()
            {
                Code = detectedNamespace + BaseClass,
                Path = contextPath,
            });
        }

        return defaultModel;
    }
}

